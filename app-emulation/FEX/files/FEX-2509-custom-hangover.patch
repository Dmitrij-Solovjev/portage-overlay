From e5d51a20b29bba1c13097dcecf4a8cc95e32c2bc Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Mon, 4 Aug 2025 14:28:58 -0400
Subject: [PATCH 1/5] RegisterAllocationPass: simplify next-use logic

I doubt this will fix the regression but it might make it easier to identify.

Signed-off-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 .../IR/Passes/RegisterAllocationPass.cpp      | 75 ++++++++-----------
 1 file changed, 30 insertions(+), 45 deletions(-)

diff --git a/FEXCore/Source/Interface/IR/Passes/RegisterAllocationPass.cpp b/FEXCore/Source/Interface/IR/Passes/RegisterAllocationPass.cpp
index befd4fef11..ae0bfdd424 100644
--- a/FEXCore/Source/Interface/IR/Passes/RegisterAllocationPass.cpp
+++ b/FEXCore/Source/Interface/IR/Passes/RegisterAllocationPass.cpp
@@ -230,11 +230,11 @@ class ConstrainedRAPass final : public RegisterAllocationPass {
 
       const uint8_t NumArgs = IR::GetRAArgs(IROp->Op);
       for (int i = NumArgs - 1; i >= 0; --i) {
-        auto& Arg = IROp->Args[i];
-        Arg.ClearKill();
+        auto V = IROp->Args[i];
+        V.ClearKill();
 
-        if (!Arg.IsInvalid()) {
-          const uint32_t Index = Arg.ID().Value;
+        if (IsValidArg(V)) {
+          const uint32_t Index = V.ID().Value;
 
           SourcesNextUses.push_back(NextUses[Index]);
           NextUses[Index] = IP;
@@ -684,13 +684,22 @@ void ConstrainedRAPass::Run(IREmitter* IREmit_) {
       //
       // This happens before freeing killed sources, since we need all sources in
       // the register file simultaneously.
+      //
+      // Also update next-use info, again only relevant if we've spilled.
       if (AnySpilledBeforeThisInstruction) {
         for (auto s = 0; s < IR::GetRAArgs(IROp->Op); ++s) {
-          if (!IsValidArg(IROp->Args[s])) {
+          auto V = IROp->Args[s];
+          V.ClearKill();
+
+          if (!IsValidArg(V)) {
             continue;
           }
 
-          Ref Old = IR->GetNode(IROp->Args[s]);
+          Ref Old = IR->GetNode(V);
+
+          SourceIndex--;
+          LOGMAN_THROW_A_FMT(SourceIndex >= 0, "Consistent source count");
+          NextUses[V.ID().Value] = SourcesNextUses[SourceIndex];
 
           if (!IsInRegisterFile(Old)) {
             IREmit->SetWriteCursorBefore(CodeNode);
@@ -702,50 +711,26 @@ void ConstrainedRAPass::Run(IREmitter* IREmit_) {
             RemapReg(Old, PhysicalRegister(Fill));
           }
         }
+      }
 
-        for (auto s = 0; s < IR::GetRAArgs(IROp->Op); ++s) {
-          if (IROp->Args[s].IsInvalid()) {
-            continue;
-          }
-
-          Ref Node = IR->GetNode(IROp->Args[s]);
-          auto ID = IR->GetID(Node).Value;
-          auto Reg = SSAToReg[ID];
-
-          SourceIndex--;
-          LOGMAN_THROW_A_FMT(SourceIndex >= 0, "Consistent source count");
-
-          if (!Reg.IsInvalid()) {
-            IROp->Args[s].SetImmediate(Reg.Raw);
-
-            if (!SourcesNextUses[SourceIndex]) {
-              LOGMAN_THROW_A_FMT(IsInRegisterFile(Node), "sources in file");
-              FreeReg(Reg);
-            }
-          }
-
-          NextUses[ID] = SourcesNextUses[SourceIndex];
+      for (auto s = 0; s < IR::GetRAArgs(IROp->Op); ++s) {
+        if (IROp->Args[s].IsInvalid()) {
+          continue;
         }
-      } else {
-        for (auto s = 0; s < IR::GetRAArgs(IROp->Op); ++s) {
-          if (IROp->Args[s].IsInvalid()) {
-            continue;
-          }
-
-          bool Kill = IROp->Args[s].HasKill();
-          IROp->Args[s].ClearKill();
-          Ref Node = IR->GetNode(IROp->Args[s]);
-          auto ID = IR->GetID(Node).Value;
-          auto Reg = SSAToReg[ID];
 
-          if (!Reg.IsInvalid()) {
-            if (Kill) {
-              LOGMAN_THROW_A_FMT(IsInRegisterFile(Node), "sources in file");
-              FreeReg(Reg);
-            }
+        bool Kill = IROp->Args[s].HasKill();
+        IROp->Args[s].ClearKill();
+        Ref Node = IR->GetNode(IROp->Args[s]);
+        auto ID = IR->GetID(Node).Value;
+        auto Reg = SSAToReg[ID];
 
-            IROp->Args[s].SetImmediate(Reg.Raw);
+        if (!Reg.IsInvalid()) {
+          if (Kill) {
+            LOGMAN_THROW_A_FMT(IsInRegisterFile(Node), "sources in file");
+            FreeReg(Reg);
           }
+
+          IROp->Args[s].SetImmediate(Reg.Raw);
         }
       }
 

From 43092ce48bca86a47b82d47acc415e0da16600ab Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Mon, 4 Aug 2025 17:04:21 -0400
Subject: [PATCH 2/5] RegisterAllocationPass: fix SRA spilling corner

I hate this.

Signed-off-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 .../IR/Passes/RegisterAllocationPass.cpp         | 16 ++++++++++++++--
 1 file changed, 14 insertions(+), 2 deletions(-)

diff --git a/FEXCore/Source/Interface/IR/Passes/RegisterAllocationPass.cpp b/FEXCore/Source/Interface/IR/Passes/RegisterAllocationPass.cpp
index ae0bfdd424..b317c9368a 100644
--- a/FEXCore/Source/Interface/IR/Passes/RegisterAllocationPass.cpp
+++ b/FEXCore/Source/Interface/IR/Passes/RegisterAllocationPass.cpp
@@ -149,8 +149,20 @@ class ConstrainedRAPass final : public RegisterAllocationPass {
 
   bool HasSource(IROp_Header* I, PhysicalRegister Reg) {
     for (auto s = 0; s < IR::GetRAArgs(I->Op); ++s) {
-      if (I->Args[s].IsImmediate() && PhysicalRegister(I->Args[s]) == Reg) {
-        return true;
+      if (I->Args[s].IsImmediate()) {
+        // When spilling for a destination, we'll see register sources
+        if (PhysicalRegister(I->Args[s]) == Reg) {
+          return true;
+        }
+      } else {
+        // When spilling for SRA correctness, we'll see SSA sources. This is
+        // pretty obscure.
+        auto V = I->Args[s];
+        V.ClearKill();
+
+        if (IsValidArg(V) && SSAToReg[V.ID().Value] == Reg) {
+          return true;
+        }
       }
     }
 

From 5836309525c862bea2064ea0d89109b7844a4410 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Mon, 4 Aug 2025 16:45:15 -0400
Subject: [PATCH 3/5] unittests: add blake3 test

this provokes RA spilling and hit an assertion fail on main.

Signed-off-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 unittests/ASM/FEX_bugs/Blake3.asm | 56 +++++++++++++++++++++++++++++++
 1 file changed, 56 insertions(+)
 create mode 100644 unittests/ASM/FEX_bugs/Blake3.asm

diff --git a/unittests/ASM/FEX_bugs/Blake3.asm b/unittests/ASM/FEX_bugs/Blake3.asm
new file mode 100644
index 0000000000..bade4fcfa4
--- /dev/null
+++ b/unittests/ASM/FEX_bugs/Blake3.asm
@@ -0,0 +1,56 @@
+%ifdef CONFIG
+{
+}
+%endif
+
+vblendps ymm3, ymm12, ymm9, 0xcc
+vperm2f128 ymm12, ymm1, ymm2, 0x20
+vmovups [rel .data_result + 0], ymm12
+vunpckhps ymm14, ymm4, ymm5
+vblendps ymm4, ymm8, ymm0, 0xcc
+vunpckhps ymm15, ymm6, ymm7
+vperm2f128 ymm7, ymm3, ymm4, 0x20
+vmovups [rel .data_result + 32], ymm7
+vshufps ymm5, ymm10, ymm13, 0x4e
+vblendps ymm6, ymm5, ymm13, 0xcc
+vshufps ymm13, ymm14, ymm15, 0x4e
+vblendps ymm10, ymm10, ymm5, 0xcc
+vblendps ymm14, ymm14, ymm13, 0xcc
+vperm2f128 ymm8, ymm10, ymm14, 0x20
+vmovups [rel .data_result + (32 * 2)], ymm8
+vblendps ymm15, ymm13, ymm15, 0xcc
+vperm2f128 ymm13, ymm6, ymm15, 0x20
+vmovups [rel .data_result + (32 * 3)], ymm13
+vperm2f128 ymm9, ymm1, ymm2, 0x31
+vperm2f128 ymm11, ymm3, ymm4, 0x31
+vmovups [rel .data_result + (32 * 4)], ymm9
+vperm2f128 ymm14, ymm10, ymm14, 0x31
+vperm2f128 ymm15, ymm6, ymm15, 0x31
+vmovups [rel .data_result + (32 * 5)], ymm11
+vmovups [rel .data_result + (32 * 6)], ymm14
+vmovups [rel .data_result + (32 * 7)], ymm15
+vmovdqa ymm0, [rel .data_stack + (32 * 0)]
+vpaddd  ymm1, ymm0, [rel .data_stack + (32 * 1)]
+vmovdqa [rel .data_stack + (32 * 1)], ymm1
+vpxor   ymm0, ymm0, [rel .data]
+vpxor   ymm2, ymm1, [rel .data + 32]
+
+hlt
+
+align 4096
+.data:
+dq 0, 0, 0, 0, 0, 0
+dq 0, 0, 0, 0, 0, 0
+
+.data_stack:
+dq 0, 0, 0, 0
+dq 0, 0, 0, 0
+
+.data_result:
+dq 0, 0, 0, 0
+dq 0, 0, 0, 0
+dq 0, 0, 0, 0
+dq 0, 0, 0, 0
+dq 0, 0, 0, 0
+dq 0, 0, 0, 0
+dq 0, 0, 0, 0

From 93c428ae53cf48e572e338114bb6b4346df85b4f Mon Sep 17 00:00:00 2001
From: Ryan Houdek <Sonicadvance1@gmail.com>
Date: Tue, 5 Aug 2025 19:51:54 -0700
Subject: [PATCH 4/5] Docs: Update for release FEX-2508.1

---
 docs/SourceOutline.md | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/docs/SourceOutline.md b/docs/SourceOutline.md
index b852241747..ccf6f54aad 100644
--- a/docs/SourceOutline.md
+++ b/docs/SourceOutline.md
@@ -1,4 +1,4 @@
-# FEX-2508
+# FEX-2508.1
 
 ## FEXCore
 See [FEXCore/Readme.md](../FEXCore/Readme.md) for more details

From f6dc866e21a9b38b85c201f317af3193202373c3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Andr=C3=A9=20Zwing?= <nerv@dawncrow.de>
Date: Sun, 13 Oct 2024 11:48:55 +0200
Subject: [PATCH 5/5] WOW64: State which emulator is in use

---
 Source/Windows/ARM64EC/Module.cpp | 2 ++
 Source/Windows/WOW64/Module.cpp   | 2 ++
 2 files changed, 4 insertions(+)

diff --git a/Source/Windows/ARM64EC/Module.cpp b/Source/Windows/ARM64EC/Module.cpp
index e8cfb5fb6c..ca11e01f1c 100644
--- a/Source/Windows/ARM64EC/Module.cpp
+++ b/Source/Windows/ARM64EC/Module.cpp
@@ -615,6 +615,8 @@ NTSTATUS ProcessInit() {
   // Not applicable to Windows
   FEXCore::Config::Set(FEXCore::Config::ConfigOption::CONFIG_TSOAUTOMIGRATION, "0");
 
+  __wine_dbg_output("starting FEX based libarm64ecfex.dll\n");
+
   FEXCore::Profiler::Init("", "");
 
   FEXCore::Context::InitializeStaticTables(FEXCore::Context::MODE_64BIT);
diff --git a/Source/Windows/WOW64/Module.cpp b/Source/Windows/WOW64/Module.cpp
index 500396602d..600cdb68da 100644
--- a/Source/Windows/WOW64/Module.cpp
+++ b/Source/Windows/WOW64/Module.cpp
@@ -481,6 +481,8 @@ void BTCpuProcessInit() {
   // Not applicable to Windows
   FEXCore::Config::Set(FEXCore::Config::ConfigOption::CONFIG_TSOAUTOMIGRATION, "0");
 
+  __wine_dbg_output("starting FEX based libwow64fex.dll\n");
+
   FEXCore::Profiler::Init("", "");
 
   FEXCore::Context::InitializeStaticTables(FEXCore::Context::MODE_32BIT);
